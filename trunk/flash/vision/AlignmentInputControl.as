/********************************************************************** Software License Agreement (BSD License)**  Copyright (c) 2008, University of Illinois at Urbana-Champaign*  All rights reserved.**  Redistribution and use in source and binary forms, with or without*  modification, are permitted provided that the following conditions*  are met:**   * Redistributions of source code must retain the above copyright*     notice, this list of conditions and the following disclaimer.*   * Redistributions in binary form must reproduce the above*     copyright notice, this list of conditions and the following*     disclaimer in the documentation and/or other materials provided*     with the distribution.*   * Neither the name of the University of Illinois nor the names of its*     contributors may be used to endorse or promote products derived*     from this software without specific prior written permission.**  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE*  POSSIBILITY OF SUCH DAMAGE.*********************************************************************//***** Author: Alexander Sorokin, Department of Computer Science,*                                  University of Illinois at Urbana-Champaign.* Advised by: David Forsyth.*****/package vision{	import flash.display.*;	//import flash.display.Shape;	import fl.controls.Label;	import flash.events.MouseEvent;	import flash.events.Event;	import vision.AlignmentMarker;	dynamic public class AlignmentInputControl extends MovieClip	{		const IDLE:String = "idle";		const EDITING:String = "edit";		const READY:String = "ready";		var ptsX:Array;		var ptsY:Array;		var ptsMarker:Array;		var ptsTime:Array;						var numPts:Number;		var thePolygon:Shape;		var maxPoints:Number;		var hitTime:Number;		var now:Date;		var makeActive;		var lineColor;		var flag_bad:Boolean;		var Mode=READY;		//lblRemoveLast.visible=true;		//btnRemoveLast.visible=false;				function AlignmentInputControl()		{			now = new Date();			hitTime=now.getTime();			//this.btnFinishShape.addEventListener(MouseEvent.CLICK, onFinishShapeClick);			this.pdClickArea.addEventListener(MouseEvent.CLICK, handleRegularClick);			//this.btnRemoveLast.addEventListener(MouseEvent.CLICK, onRemoveLastSegmentClick);			//this.btnRemoveLast.visible=false;			//this.btnFinishShape.visible=false;			this.maxPoints = 6;			this.flag_bad = false;			gotoAndStop(1);		}		public function set_bad_flag(flag:Boolean):void{			flag_bad=flag;			if(flag_bad){				gotoAndStop(2);			}else{				gotoAndStop(1);			}		}		function onFinishShapeClick(event:MouseEvent):void {			//numPts++;			//ptsX[numPts]=event.localX;			//ptsY[numPts]=event.localY;			var now:Date = new Date();			this.hitTime=now.getTime();			//this.thePolygon.graphics.lineTo(ptsX[1], ptsY[1]);			this.Mode=IDLE;			//this.btnFinishShape.visible=false;			//this.btnRemoveLast.visible=false;			//lblRemoveLast.visible=false;			var done_event:Event = new Event("my_input_finished");    		this.dispatchEvent(done_event);								trace(event.currentTarget.toString() + "Finish");		}		function handleRegularClick(event:MouseEvent):void {			if(flag_bad)			{				return;			}			if (this.Mode==IDLE) {				trace("Idle");			} else if (this.Mode==READY) {				//this.btnFinishShape.x=event.localX;				//this.btnFinishShape.y=event.localY;				//this.btnFinishShape.visible=true;				//this.btnRemoveLast.visible=true;				//lblRemoveLast.visible=true;				this.Mode=EDITING;				ptsX=new Array();				ptsY=new Array();				ptsMarker=new Array();				ptsTime = new Array();				numPts=0;				//this.thePolygon= new Shape();				//this.thePolygon.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,				//                               CapsStyle.NONE, JointStyle.MITER, 10);				numPts++;				ptsX[numPts]=event.localX;				ptsY[numPts]=event.localY;				var now:Date = new Date();				ptsTime[numPts]=now.getTime();				var m:vision.AlignmentMarker=new vision.AlignmentMarker();				ptsMarker[numPts]=m;				m.setMarkerID(numPts);								m.x=event.localX;				m.y=event.localY;				event.currentTarget.addChild(m);								//thePolygon.graphics.moveTo(event.localX, event.localY);				//event.currentTarget.addChild(thePolygon);			} else {				numPts++;				ptsX[numPts]=event.localX;				ptsY[numPts]=event.localY;				var now:Date = new Date();				ptsTime[numPts]=now.getTime();				var m:vision.AlignmentMarker=new vision.AlignmentMarker();				ptsMarker[numPts]=m;				m.setMarkerID(numPts);				m.x=event.localX;				m.y=event.localY;				event.currentTarget.addChild(m);							if(numPts==maxPoints){					var now:Date = new Date();					this.hitTime=now.getTime();					this.Mode=IDLE;					//this.btnFinishShape.visible=false;					//this.btnRemoveLast.visible=false;					var done_event:Event = new Event("my_input_finished");    				this.dispatchEvent(done_event);											}								//thePolygon.graphics.lineTo(event.localX, event.localY);				/*trace(event.currentTarget.toString() + 				" dispatches MouseEvent. Local coords [" + 				event.localX + "," + event.localY + "] Stage coords [" + 				event.stageX + "," + event.stageY + "]");*/			}			/*trace(event.currentTarget.toString() + 			" dispatches MouseEvent. Local coords [" + 			event.localX + "," + event.localY + "] Stage coords [" + 			event.stageX + "," + event.stageY + "]");*/			var now:Date = new Date();			this.hitTime=now.getTime();		}		function onRemoveLastSegmentClick(event:MouseEvent):void {			if (this.Mode == EDITING) {				var now:Date = new Date();				this.hitTime=now.getTime();				//this.thePolygon.graphics.clear();				//thePolygon.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,				//                              CapsStyle.NONE, JointStyle.MITER, 10);				if (this.numPts>1) {					var m:vision.AlignmentMarker=ptsMarker[numPts];					m.parent.removeChild(m);					this.numPts--;/*					this.thePolygon.graphics.moveTo(ptsX[1], ptsY[1]);					if (this.numPts>1) {						for (var i=2; i<=this.numPts; i++) {							this.thePolygon.graphics.lineTo(this.ptsX[i], this.ptsY[i]);						}					}*/				} else if (this.numPts==1) {					this.numPts=0;					this.Mode=READY;				}			}		}				public function read_xml_annotation(annotation:XML):void{			var pts=annotation.pt;			ptsX=new Array();			ptsY=new Array();			ptsMarker=new Array();			ptsTime = new Array();						numPts=0;			set_bad_flag(int(annotation.@invalid));			for(var iP in pts){				var p=pts[iP];				numPts++;				ptsX[numPts]=p.@x;				ptsY[numPts]=p.@y;				var now:Date = new Date();				ptsTime[numPts]=now.getTime();				var m:vision.AlignmentMarker=new vision.AlignmentMarker();				ptsMarker[numPts]=m;				m.setMarkerID(numPts);				m.x=p.@x;				m.y=p.@y;				this.pdClickArea.addChild(m);								//this.btnFinishShape.x=p.@x;				//this.btnFinishShape.y=p.@y;				//this.btnFinishShape.visible=true;							}		}		public function get_xml_annotation():String		{					//var object_name=this.label.split('_')[0];			//var object_sqn=this.label.split('_')[1];			var xmlStr:String="";						if(flag_bad){				xmlStr='<polygon  invalid="1">';			}else{				xmlStr='<polygon  invalid="0">';			}			for(var iPt=1;iPt<=this.numPts;iPt++){				var lx=ptsMarker[iPt].x;				var ly=ptsMarker[iPt].y;				var t=ptsTime[iPt];								xmlStr +='\t<pt x="'+lx+'" y="'+ly+'" ct="'+t+'"/>\n';			}			xmlStr+="</polygon>";						return xmlStr;		}							//lx=(lx-rootObj.oX)*rootObj.ratio;			//ly=(ly-rootObj.oY)*rootObj.ratio;					//function makeDisplayActive(holder){		//}		//makeActive=makeDisplayActive;	}}