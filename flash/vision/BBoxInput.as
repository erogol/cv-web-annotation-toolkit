/********************************************************************** Software License Agreement (BSD License)**  Copyright (c) 2008, University of Illinois at Urbana-Champaign*  All rights reserved.**  Redistribution and use in source and binary forms, with or without*  modification, are permitted provided that the following conditions*  are met:**   * Redistributions of source code must retain the above copyright*     notice, this list of conditions and the following disclaimer.*   * Redistributions in binary form must reproduce the above*     copyright notice, this list of conditions and the following*     disclaimer in the documentation and/or other materials provided*     with the distribution.*   * Neither the name of the University of Illinois nor the names of its*     contributors may be used to endorse or promote products derived*     from this software without specific prior written permission.**  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE*  POSSIBILITY OF SUCH DAMAGE.*********************************************************************//***** Author: Alexander Sorokin, Department of Computer Science,*                                  University of Illinois at Urbana-Champaign.* Advised by: David Forsyth.*****/package vision{			import flash.display.*;		//import flash.display.Shape;	import fl.controls.Label;	import flash.events.MouseEvent;	import flash.events.Event;	 	 dynamic public class BBoxInput extends MovieClip	 {		public const IDLE:String = "idle";		public const EDITING_BOX:String = "edit_box";		public const EDITING_DETAILS:String = "edit_details";		public const READY:String = "ready";				public const DISPLAY_INLINE:String = "display_inline";						public var ptsX:Array;		public var ptsY:Array;		public var ptsTime:Array;		public var tokens:Array;		public var keys:Array;		public var clickTimes:Array;		public var numPts:Number;		public var thePolygon:Shape;		public var str_joint_names:String = new String("hood-left,hood-right,trunk-right,trunk-left");		public var joint_names:Array = str_joint_names.split(",");		public  var joint_links:Array=new Array();		public var detail_object=null;		public var parent_display=null;		public var parent_tag=null;		public var parent_polygon=null;		public var theBox=null;				public var hitTime:Number;		public var now:Date = new Date();				public var makeActive;				public var lineColor;		public var bbox;		public var Mode=READY;		function BBoxInput(){			joint_links[1]=[];			joint_links[2]=[1];			joint_links[3]=[2];			joint_links[4]=[3,1];			hitTime=now.getTime();			btnRemoveLast.visible=false;			btnDone.visible=false;			theGuide.visible=true;			theGuide.gotoAndStop(1);			pdClickArea.addEventListener(MouseEvent.CLICK, handleRegularClick);			btnRemoveLast.addEventListener(MouseEvent.CLICK, onRemoveLastSegmentClick);			btnDone.addEventListener(MouseEvent.CLICK, onBtnDoneClick);		}				public function get_xml_annotation():String		{					var object_name=this.label.split('_')[0];			var object_sqn=this.label.split('_')[1];									 var xmlStr:String="";			 xmlStr ='<bbox name="'+ object_name +'" sqn="'+ object_sqn +'" left="'+ bbox[0] +'" top="'+ bbox[1] +'" width="'+ bbox[2] +'" height="'+ bbox[3] +'">\n';			 for(var iPt=1;iPt<=this.numPts;iPt++){				var lx=ptsX[iPt];				var ly=ptsY[iPt];				var t =ptsTime[iPt];								xmlStr +='\t<pt x="'+lx+'" y="'+ly+'" ct="'+t+'"/>\n';			}		 			xmlStr += '</bbox>\n';			 			 return xmlStr;		}				public function set_xml_annotation(bbox):void		{		}		function onFinishShapeClick(event:MouseEvent):void		{			var now:Date = new Date();			this.hitTime=now.getTime();			thePolygon.graphics.lineTo(ptsX[1], ptsY[1]);			this.Mode=IDLE;			btnRemoveLast.visible=false;			theGuide.visible=false;		}//btnFinishShape.addEventListener(MouseEvent.CLICK, onFinishShapeClick);	function handleRegularClick(event:MouseEvent):void{	var links;	var n;	var i;	var now:Date;	var key=0;	var mark;		if(event.altKey)	{		key=1;	}		if(this.Mode==IDLE){		trace("Idle")	}else if(this.Mode==READY){		//btnFinishShape.x=event.localX;		//btnFinishShape.y=event.localY;		//btnFinishShape.visible=true;		btnRemoveLast.visible=true;		theGuide.visible=true;		//lblRemoveLast.visible=true;		this.Mode=EDITING_BOX;				ptsX=new Array();		ptsY=new Array();		ptsTime=new Array();		tokens=new Array();		keys=new Array();		numPts=0;   		thePolygon= new Shape();            thePolygon.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,                               CapsStyle.NONE, JointStyle.MITER, 10);		numPts++;		ptsX[numPts]=event.localX;		ptsY[numPts]=event.localY;		now = new Date();		ptsTime[numPts]=now.getTime();		keys[numPts]=key;		theGuide.gotoAndStop(numPts*5+1);				mark=new MarkSymbol();		tokens[numPts]=mark;				mark.x=event.localX;		mark.y=event.localY;		pdClickArea.addChild(mark);			 			}else if(this.Mode==EDITING_BOX){				if(numPts<2)		{			if(event.localX>=ptsX[numPts] && event.localY>=ptsY[numPts] &&				! (event.localX==ptsX[numPts] && event.localY==ptsY[numPts]))			{			numPts++;			ptsX[numPts]=event.localX;			ptsY[numPts]=event.localY;			now = new Date();			ptsTime[numPts]=now.getTime();			keys[numPts]=key;							//theGuide.gotoAndStop(numPts*5+1);	 	//thePolygon.graphics.lineTo(event.localX, event.localY);			//mark2=new MarkSymbol();			//tokens[numPts]=mark2;			//mark2.x=event.localX;			//mark2.y=event.localY;						theBox=new Shape();			lineColor=0xFFFFFF;        	theBox.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,                               CapsStyle.NONE, JointStyle.MITER, 10);			var bX=ptsX[1];			var bY=ptsY[1];			var bW=ptsX[2]-bX+1;			var bH=ptsY[2]-bY+1;			theBox.graphics.moveTo(bX,bY);			theBox.graphics.lineTo(bX+bW,bY);			theBox.graphics.lineTo(bX+bW,bY+bH);			theBox.graphics.lineTo(bX,bY+bH);			theBox.graphics.lineTo(bX,bY);			tokens[numPts]=theBox;			//the_sites_holder.addChild(thePolygon);			pdClickArea.addChild(theBox);			btnDone.visible=true;			}					////		 if(numPts==2){//			 var cX=0;//			 var cY=0;//			 for(var ii:Number=1;ii<=numPts;ii++)//			 {//				cX=cX+ptsX[ii];//				cY=cY+ptsY[ii];	//			 }//			 cX=cX/numPts;//			 cY=cY/numPts;////			 var tag:TextField=new TextField();//			 tag.text=this.data.substr(4);//			 tag.opaqueBackground=0xFFFFFF;//			 tag.autoSize=TextFieldAutoSize.RIGHT;//			 //tag.textField//			 //tag.y=cY;//			 //			 this.addChild(tag);//			 tag.x=cX-tag.width/2;//			 tag.y=cY-tag.height/2;//			 this.Mode=IDLE;//			//btnFinishShape.visible=false;//			btnRemoveLast.visible=false;//			theGuide.visible=false;//			//			var done_event:Event = new Event("my_input_finished");//        	this.dispatchEvent(done_event);//		 }		}		trace(event.currentTarget.toString() + 			" dispatches MouseEvent. Local coords [" + 			event.localX + "," + event.localY + "] Stage coords [" + 			event.stageX + "," + event.stageY + "]");	}	trace(event.currentTarget.toString() + 			" dispatches MouseEvent. Local coords [" + 			event.localX + "," + event.localY + "] Stage coords [" + 			event.stageX + "," + event.stageY + "]");	now = new Date();	this.hitTime=now.getTime();}////var mouse_localX=0;//var mouse_localY=0;//pdClickArea.addEventListener(MouseEvent.MOUSE_MOVE, mouseTracker);//function mouseTracker(event:MouseEvent):void//{//	mouse_localX=event.localX;//	mouse_localY=event.localY;//	//}////pdClickArea.addEventListener(KeyboardEvent.KEY_UP, handleKeyboard);////function handleKeyboard(event:KeyboardEvent):void//{//	var links;//	var n;//	var i;//	var now:Date;//	var key=event.charCode;//	trace(key);//	if(key=='s' || key=='g'){//	if(this.Mode==IDLE){//		trace("Idle")//	}else if(this.Mode==READY){//		//btnFinishShape.x=event.localX;//		//btnFinishShape.y=event.localY;//		//btnFinishShape.visible=true;//		btnRemoveLast.visible=true;//		theGude.visible=true;//		//lblRemoveLast.visible=true;//		this.Mode=EDITING;//		//		ptsX=new Array();//		ptsY=new Array();//		clickTimes=new Array();//		numPts=0;//   		thePolygon= new Shape();    ////        thePolygon.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,//                               CapsStyle.NONE, JointStyle.MITER, 10);////		numPts++;//		ptsX[numPts]=mouse_localX;//		ptsY[numPts]=mouse_localY;//		theGude.gotoAndStop(numPts*5+1);//		now = new Date();//		clickTimes[numPts]=now.getTime();//		// 		 thePolygon.graphics.moveTo(mouse_localX, mouse_localY);//		 links=joint_links[numPts];//		 for(i=0;i<links.length;i++)//		 {//			n=links[i];//			thePolygon.graphics.lineTo(ptsX[n], ptsY[n]);//		 }//		 event.currentTarget.addChild(thePolygon);// 		//	}else{		//		if(numPts<14)//		{//		numPts++;//		ptsX[numPts]=mouse_localX;//		ptsY[numPts]=mouse_localY;//		now = new Date();//		clickTimes[numPts]=now.getTime();//		//		theGude.gotoAndStop(numPts*5+1);//	 	//thePolygon.graphics.lineTo(event.localX, event.localY);//// 		 thePolygon.graphics.moveTo(mouse_localX, mouse_localY);//		 links=joint_links[numPts];//		 for(i=0;i<links.length;i++)//		 {//			 n=links[i];//			trace(n);// 		 	thePolygon.graphics.moveTo(ptsX[numPts], ptsY[numPts]);//			thePolygon.graphics.lineTo(ptsX[n], ptsY[n]);////		 }		//		 if(numPts==14){//			this.Mode=IDLE;//			//btnFinishShape.visible=false;//			btnRemoveLast.visible=false;//			theGude.visible=false;//		 }//		}//		//trace(event.currentTarget.toString() + ////			" dispatches MouseEvent. Local coords [" + ////			event.localX + "," + event.localY + "] Stage coords [" + ////			event.stageX + "," + event.stageY + "]");//	}////	trace(event.currentTarget.toString() + ////			" dispatches MouseEvent. Local coords [" + ////			event.localX + "," + event.localY + "] Stage coords [" + ////			event.stageX + "," + event.stageY + "]");//	now = new Date();//	this.hitTime=now.getTime();//	}//}function onRemoveLastSegmentClick(event:MouseEvent):void{	if(this.Mode == EDITING_BOX)	{	var now:Date = new Date();	this.hitTime=now.getTime();	this.thePolygon.graphics.clear();    thePolygon.graphics.lineStyle(2, lineColor, 1, false, LineScaleMode.VERTICAL,                               CapsStyle.NONE, JointStyle.MITER, 10);		if(this.numPts>1)	{		this.pdClickArea.removeChild(tokens[numPts]);		this.numPts--;		//this.thePolygon.graphics.moveTo(ptsX[1], ptsY[1]);		if(this.numPts>1)		{			for(var iPt=2;iPt<=this.numPts;iPt++)			{ 				//thePolygon.graphics.moveTo(ptsX[iPt], ptsY[iPt]);		 		var links=joint_links[iPt];		 		for(var i=0;i<links.length;i++)		 		{			 		var n=links[i];					thePolygon.graphics.moveTo(ptsX[iPt], ptsY[iPt]);					thePolygon.graphics.lineTo(ptsX[n], ptsY[n]);		 		}		 	}		}	}else if(this.numPts==1)	{		this.pdClickArea.removeChild(tokens[numPts]);		this.numPts=0;		this.Mode=READY;	}	btnDone.visible=false;	theGuide.gotoAndStop(numPts*5+1);	}}			function onBtnDoneClick(event:MouseEvent):void{	if(this.Mode == EDITING_BOX && this.numPts==2)	{		var done_event:Event = new Event("my_input_finished");    	this.dispatchEvent(done_event);			}}//function makeDisplayActive(holder){//}//makeActive=makeDisplayActive;		 	 } } 