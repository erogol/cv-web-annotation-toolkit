/********************************************************************** Software License Agreement (BSD License)**  Copyright (c) 2008, University of Illinois at Urbana-Champaign*  All rights reserved.**  Redistribution and use in source and binary forms, with or without*  modification, are permitted provided that the following conditions*  are met:**   * Redistributions of source code must retain the above copyright*     notice, this list of conditions and the following disclaimer.*   * Redistributions in binary form must reproduce the above*     copyright notice, this list of conditions and the following*     disclaimer in the documentation and/or other materials provided*     with the distribution.*   * Neither the name of the University of Illinois nor the names of its*     contributors may be used to endorse or promote products derived*     from this software without specific prior written permission.**  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE*  POSSIBILITY OF SUCH DAMAGE.*********************************************************************//***** Author: Alexander Sorokin, Department of Computer Science,*                                  University of Illinois at Urbana-Champaign.* Advised by: David Forsyth.*****/package vision{			import fl.core.UIComponent;		import flash.display.*;	import fl.controls.Label;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.ui.Mouse;		import vision.CoordinateConverter;		import flash.geom.Point;	import flash.geom.Rectangle;	import vision.Box3Marker;	import vision.MarkCursor;	import vision.data.BoundingBox;	import flash.text.*;	 	 /*	 Shows the boxes. 	 Inputs 1 or more bounding boxes. 	 Sends box selection and hover? events.	 */	 dynamic public class BBox3InputComponent extends MovieClip	 {		public const ACTIVE:String = "active";		public const EDITING_ITEM:String = "edit_item";				public const WAIT_FOR_CLICK:String = "select_for_edit";		public const DISPLAY_ONLY:String = "display";		public var boxes:Array;						public var m_current_marker:vision.Box3Marker;		public var Mode=ACTIVE;				public var min_size:int;		public var rootObj;				public var allow_edit:Boolean;			public var show_tags:Boolean;				var iB;		var m_cursor:vision.MarkCursor;		var cursor_locks_count=0;		var new_bbox;		function BBox3InputComponent(){			super();						m_cursor= new vision.MarkCursor();			addChild(m_cursor);									iB=0;			boxes=new Array();			m_cursor.visible=true;						pdClickArea.visible=true;			allow_edit=true;			min_size=-1;						Mode=ACTIVE;			setupEventListeners();		}		public function set_root(newRootObj):void{			this.rootObj=newRootObj;			 			 		 }		private function onKeyDownHandler(event:KeyboardEvent):void{					}				        private function mouseOverHandler(event:MouseEvent):void {			if(this.Mode == this.DISPLAY_ONLY){				return;			}						if(cursor_locks_count==0)			{            //trace("mouseOverHandler");            Mouse.hide();						if(m_cursor!=null){								m_cursor.visible=true;				m_cursor.startDrag(true);			}			}			cursor_locks_count=cursor_locks_count+1;			//pdClickArea.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);        }        private function mouseOutHandler(event:MouseEvent):void {			if(this.Mode == this.DISPLAY_ONLY){				return;			}			cursor_locks_count=cursor_locks_count-1;			if(cursor_locks_count==0)			{            //trace("mouseOutHandler");            Mouse.show();			if(m_cursor!=null){				m_cursor.stopDrag();				m_cursor.visible=false;			}			}            //pdClickArea.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);            //cursor.visible = false;        }		private function mouseLeaveHandler(event:Event):void {			if(this.Mode == this.DISPLAY_ONLY){				return;			}			            //trace("mouseLeaveHandler");            mouseOutHandler(new MouseEvent(MouseEvent.MOUSE_MOVE));        }		private function mouseMoveHandler(event:MouseEvent):void {			if(this.Mode == this.DISPLAY_ONLY){				return;			}          			var p2:Point=pdClickArea.globalToLocal(new Point(event.stageX,event.stageY));            m_cursor.x = p2.x;            m_cursor.y = p2.y;            event.updateAfterEvent();                    }				public function get_num_boxes():Number{			return boxes.length;		}						function startBox(event:MouseEvent):void {						if(this.Mode == this.ACTIVE){				var p2:Point=pdClickArea.globalToLocal(new Point(event.stageX,event.stageY));								new_bbox=new vision.data.BoundingBox(new Rectangle(0,0,0,0));				new_bbox.text_label = "Unspecified";					m_current_marker=new vision.Box3Marker();				m_current_marker.set_root(rootObj);				if(rootObj)				{						m_current_marker.set_color(rootObj.color_manager.getColor());				}else{					m_current_marker.set_color(0x000000);									}				m_current_marker.set_box(p2.x,p2.y,0,0);				m_current_marker.x0=p2.x;				m_current_marker.y0=p2.y;				var now:Date = new Date();				m_current_marker.t0=now.getTime();				m_current_marker.addEventListener(MouseEvent.MOUSE_UP, endBox);				m_current_marker.addEventListener(MouseEvent.MOUSE_MOVE, updateBox);					pdClickArea.addChild(m_current_marker);												m_current_marker.set_lbl(new_bbox.text_label);								boxes.push(m_current_marker);				this.Mode = this.EDITING_ITEM			}		}				public function update_coordinate_system(newCoords:Rectangle,oldCoords:Rectangle):void		{			var converter=new vision.CoordinateConverter(newCoords,oldCoords);			for each(var o:Object in boxes){				var b:Box3Marker=vision.Box3Marker(o);				b.set_box(converter.convert_x(b.x),converter.convert_y(b.y),converter.convert_w(b.width),converter.convert_h(b.height));				if(b.tag!=null){					converter.convert_object(b.tag);				}			}		}						function setupEventListeners():void		{						if(this.Mode==this.ACTIVE)			{				pdClickArea.addEventListener(MouseEvent.MOUSE_DOWN, startBox);				pdClickArea.addEventListener(MouseEvent.MOUSE_UP,   endBox);				pdClickArea.addEventListener(MouseEvent.MOUSE_MOVE, updateBox);				pdClickArea.addEventListener(MouseEvent.CLICK,      killClickEvent);				pdClickArea.addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);				pdClickArea.addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);				pdClickArea.addEventListener(Event.MOUSE_LEAVE, mouseLeaveHandler);				pdClickArea.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDownHandler);				m_cursor.addEventListener(MouseEvent.MOUSE_DOWN,  startBox);				m_cursor.addEventListener(MouseEvent.MOUSE_UP,    endBox);				m_cursor.addEventListener(MouseEvent.MOUSE_MOVE,  updateBox);				m_cursor.addEventListener(MouseEvent.CLICK,       killClickEvent);				m_cursor.addEventListener(MouseEvent.MOUSE_OVER,  mouseOverHandler);				m_cursor.addEventListener(MouseEvent.MOUSE_OUT,   mouseOutHandler);				m_cursor.addEventListener(Event.MOUSE_LEAVE,      mouseLeaveHandler);				m_cursor.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDownHandler);			}			if(this.Mode==this.EDITING_ITEM)			{				throw Error("Shouldn't set handlers while editing")			}			if(this.Mode==this.WAIT_FOR_CLICK)			{				var iBox=get_num_boxes();				for(var i=0;i<iBox;i++)				{						boxes[i].addEventListener(MouseEvent.CLICK,onBoxDoubleClick);						boxes[i].idx=i;				}			}			if(this.Mode==this.DISPLAY_ONLY)			{			}		}				function removeEventListeners():void		{			if(this.Mode==this.ACTIVE)			{				pdClickArea.removeEventListener(MouseEvent.MOUSE_DOWN, startBox);				pdClickArea.removeEventListener(MouseEvent.MOUSE_UP,   endBox);				pdClickArea.removeEventListener(MouseEvent.MOUSE_MOVE, updateBox);				pdClickArea.removeEventListener(MouseEvent.CLICK,      killClickEvent);				pdClickArea.removeEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);				pdClickArea.removeEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);				pdClickArea.removeEventListener(Event.MOUSE_LEAVE, mouseLeaveHandler);				pdClickArea.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyDownHandler);				m_cursor.removeEventListener(MouseEvent.MOUSE_DOWN, startBox);				m_cursor.removeEventListener(MouseEvent.MOUSE_UP,   endBox);				m_cursor.removeEventListener(MouseEvent.MOUSE_MOVE, updateBox);				m_cursor.removeEventListener(MouseEvent.CLICK,      killClickEvent);				m_cursor.removeEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);				m_cursor.removeEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);				m_cursor.removeEventListener(Event.MOUSE_LEAVE, mouseLeaveHandler);				m_cursor.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyDownHandler);							}			if(this.Mode==this.EDITING_ITEM)			{				throw Error("Shouldn't set handlers while editing")			}			if(this.Mode==this.WAIT_FOR_CLICK)			{				var iBox=get_num_boxes();				for(var i=0;i<iBox;i++)				{					boxes[i].removeEventListener(MouseEvent.CLICK);				}						}			if(this.Mode==this.DISPLAY_ONLY)			{			}				}				function endBox(event:MouseEvent):void {			if(	this.Mode == this.EDITING_ITEM){				var p2:Point=pdClickArea.globalToLocal(new Point(event.stageX,event.stageY));				var now:Date = new Date();				m_current_marker.t1=now.getTime();								var l=Math.min(p2.x,m_current_marker.x0);				var t=Math.min(p2.y,m_current_marker.y0);				var w=Math.abs(p2.x-m_current_marker.x0);				var h=Math.abs(p2.y-m_current_marker.y0);								var bKeep=true;				if (m_current_marker.t1-m_current_marker.t0<2000){					//if less than 2 seconds, we don't create small boxes					if(w<5 && h<5){						bKeep=false;					}				}				if(!bKeep)				{					m_current_marker.parent.removeChild(m_current_marker.tag);					m_current_marker.parent.removeChild(m_current_marker);					boxes.pop();				}else{					m_current_marker.addEventListener(MouseEvent.CLICK,onBoxDoubleClick);				}								this.Mode = this.ACTIVE;			}			var input_completed:Event = new Event("input_completed");			this.dispatchEvent(input_completed);		}		function updateBox(event:MouseEvent):void {			if(	this.Mode == this.EDITING_ITEM){				var x2=event.stageX;				var y2=event.stageY;				var p2:Point=pdClickArea.globalToLocal(new Point(x2,y2));				var w=Math.abs(p2.x-m_current_marker.x0);				var h=Math.abs(p2.y-m_current_marker.y0);								var new_x=Math.min(p2.x,m_current_marker.x0);				var new_y=Math.min(p2.y,m_current_marker.y0);								var new_width=Math.abs(w);				var new_height=Math.abs(h);				m_current_marker.set_box(new_x,new_y,new_width,new_height);				m_current_marker.update_tag_location();			}		}				function killClickEvent(event:MouseEvent):void {		}		function onRemoveLastSegmentClick(event:MouseEvent):void		{			if(this.Mode == EDITING_ITEM || this.Mode == ACTIVE)			{							if(get_num_boxes()>0)				{					//var iBox=get_num_boxes();					m_current_marker=boxes.pop();					m_current_marker.parent.removeChild(m_current_marker.tag);					m_current_marker.parent.removeChild(m_current_marker);				}			}		}						public function enable_edit():void{			if(allow_edit==false){				allow_edit=true;				var iBox=get_num_boxes();				for(var i=0;i<iBox;i++)				{						boxes[i].addEventListener(MouseEvent.CLICK,onBoxDoubleClick);						boxes[i].idx=i;				}						}		}		public function disable_edit():void{			allow_edit=false;			try			{				var iBox=get_num_boxes();				for(var i=0;i<iBox;i++){						boxes[i].removeEventListener(MouseEvent.CLICK,onBoxDoubleClick);				}						}catch(e){			}		}				function onBoxDoubleClick(event:MouseEvent):void{			if(rootObj)			{				if(rootObj.active_marker!=null){					rootObj.active_marker.removeEditMode();					rootObj.active_marker=null;				}			}			this.parent.addChild(this);			if(!allow_edit){				return;			}			var box:vision.Box3Marker=vision.Box3Marker(event.currentTarget);						box.setEditMode();			if(rootObj)			{				rootObj.active_marker=box;			}			event.stopPropagation();		}																		function set boxes_data(boxes_array:Array):void{			this.boxes=boxes_array;		}				function update_boxes():void{		}						public function setDisplayMode():void		{			removeEventListeners();			this.Mode = DISPLAY_ONLY;						setupEventListeners();		}		public function setEditMode():void		{			removeEventListeners();			this.Mode = WAIT_FOR_CLICK;			setupEventListeners();		}			public function setInputMode():void		{			removeEventListeners();			this.Mode = ACTIVE;			setupEventListeners();		}		} } 